== README

This here are the mistakes I overlooked and what I could have done:

* User Session:

I could have used some form of "sign-in" authentication as guest or admin. With a UI in the homepage with "sign-in as guest or admin". This would have been a better solution. 

When user signs in as guest - create a new anonymous_user and redirect to root_url.
When Admin signs in - redirects to sign_in page with credentials managed by sessions controller "create" maybe, if User.authenticate(credentials) and user admin attribute :admin eq true, then redirect to root_url.

Then when use signs out, this was another miss on my part I just noticed afterwards, I tried to create a destroy session link for testing purposes, BUT I could have implemented that as a sign_out button which calls action sessions#destroy setting the session[:user_id] to nil

The reason I went with this route was because I thought I could have got away with relying on the session of the user when they opened this page. This was clearly an assumption on my part to assume that each user's session was defined on the browser session. 

* Admin viewing all comments vs Guest viewing all comments

I should have in users#index when pulling all the comments, I should have did the following if I were to follow my current implementation, kinda hacky, but I believe this will work:

if @current_user.admin
  @comments = Comment.all
else
  # For all other guest users
  last_current_user_comment = Comment.where("user_id = ?", @current_user.id).first
  # This activerecord query will pull all comments after the user
  # created_at time, which I believe I should have done.
  @comments = Comment.where("created_at > ?", @current_user.created_at)
end

* Setting Admin-ship through GET request

I currently have an action in User that we can invoke update_admin
It takes in params[:user_id] and params[:admin] - I could have just set it up the route to expect update_admin/:user_id/:admin, but update_admin/:user_id?admin=<true||false>

<tt>rake doc:app</tt>.
